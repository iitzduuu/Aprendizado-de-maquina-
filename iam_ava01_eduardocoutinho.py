# -*- coding: utf-8 -*-
"""IAM_AVA01_eduardocoutinho.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1zSy4pr8EnxQuj3p7LhnIf3ryDO53Ik8m

Universidade Federal da Bahia                                                           
Escola Politécnica                                                               
Departamento de Engenharia Elétrica e de Computação                              
Disciplina: Intro. ao Aprendizado de Máquina (ENGG67)                            
Professor: Antônio C. L. Fernandes Jr.                                           
Aluno(a): Aécio Ferreira Barbosa Caldas e Eduardo Coutinho
"""

import pandas as pd

#importa a biblioteca pandas

pip install ucimlrepo # instala a biblioteca ucimlrepo

from ucimlrepo import fetch_ucirepo

# busca o dataset da ucimlrepo
heart_disease = fetch_ucirepo(id=45)

# define os datas
X = heart_disease.data.features
y = heart_disease.data.targets

# printa as informações do metadata
print(heart_disease.metadata)

# printa os dados
print(heart_disease.variables)

df = pd.read_csv('https://archive.ics.uci.edu/static/public/45/data.csv') #lê a base de dados
print(df.columns) #printa colunas da base de dados

"""a:                                                                                        
É multivariado pois apresenta mais de uma coluna de dados

b:
1.   age:

*   Tipo: Numérico
*   Escala: Razão (idade é uma medida contínua com um zero absoluto, onde zero significa ausência de idade)


2.  sex:



*   Tipo: Categórico
*   Escala: Nominal (0 = feminino, 1 = masculino)



3.   cp (tipo de dor no peito):



*   Tipo: Categórico
*   Escala: Ordinal (códigos de 1 a 4 que indicam diferentes tipos de dor no peito com uma hierarquia de intensidade)


4.   trestbps (pressão arterial em repouso):


*   Tipo: Numérico
*   Escala: Razão (é uma medida contínua com zero absoluto)


5.   chol (colesterol sérico):


*   Tipo: Numérico
*   Escala: Razão (é uma medida contínua com zero absoluto)


6.   fbs (glicose em jejum, >120 mg/dl):


*   Tipo: Categórico
*   Escala: Nominal (0 = não, 1 = sim)



7.   restecg (resultados do eletrocardiograma):



*   Tipo: Categórico
*   Escala: Nominal (indica se há anormalidades específicas no ECG)


8.   thalach (frequência cardíaca máxima alcançada):



*   Tipo: Numérico
*   Escala: Razão (medida contínua com zero absoluto)


9.   exang (angina induzida por exercício):



*   Tipo: Categórico
*   Escala: Nominal (0 = não, 1 = sim)


10.  oldpeak (depressão do segmento ST):


*   Tipo: Numérico
*   Escala: Intervalar (diferença entre valores faz sentido, mas não há um zero absoluto)


11. slope (inclinação do segmento ST):


*   Tipo: Categórico
*   Escala: Ordinal (representa diferentes inclinações do segmento ST, com uma hierarquia)


12. ca (número de vasos principais coloridos por fluoroscopia):


*   Tipo: Numérico
*   Escala: Intervalar (representa uma contagem de vasos, mas zero não indica ausência de quantidade absoluta)


13. thal (teste de talassemia):


*   Tipo: Categórico
*   Escala: Nominal (diferentes resultados de teste sem hierarquia)

C:
"""

#moda
moda_todos_atributos = df.mode(axis=0, numeric_only=False)  # df.mode é a função da biblioteca pandas para calcular moda// axis=o indica que queremos calcular a moda de cada coluna
print(moda_todos_atributos) #printa a moda de todos os atributos

#média


media_todos_atributos = df.mean(numeric_only=False) # df.mean é a função da biblioteca pandas para calcular média//numeric only false garante que a média de todas as categorias vai ser calculada
print(media_todos_atributos) #printa a média de todos os atributos

mediana_todos_atributos = df.median(numeric_only=False)    # df.median é a função da biblioteca pandas para calcular média//numeric only false garante que a mediana de todas as categorias vai ser calculada
print(mediana_todos_atributos) #printa a mediana de todos atributos

DV_todos_atributos = df.std(numeric_only=False)   # df.mean é af função da biblioteca pandas para calcular média//numeric only false garante que o desvio padrão de todas as categorias vai ser calculada
print(DV_todos_atributos) # printa o desvio padrão de todos os atributos

quartil1_todos_atributos = df.quantile(0.25, numeric_only=False)   # df.quantile é a função da biblioteca pandas para calcular o primeiro quartil
print(quartil1_todos_atributos) #printa o primeiro quartil de todos os atributos

terceiroquartil_todos_atributos = df.quantile(0.75, numeric_only=False)   # df.quantile é a função da biblioteca pandas para calcular o terceiro quartil
print(terceiroquartil_todos_atributos) #printa o terceiro de todos os atributos

oblq_todos_atributos = df.skew(numeric_only=False)   # df.skew é a função da biblioteca pandas para calcular a obliquidade
print(oblq_todos_atributos) #printa a obliquidade de todos os atributos

curtose_de_todos_atributos = df.kurtosis(numeric_only=False)   # df.kurtosis é a função da biblioteca pandas para calcular a curtose
print(curtose_de_todos_atributos) #printa a curtose de todos os atributos

"""D:"""

#imcompletude
valores_perdidos = df.isna().sum()   # df.isna é a função da biblioteca pandas para verificar se há valores nulos
print(valores_perdidos)

print(df.dtypes) #exibe os tipos de dados de cada coluna

"""a coluna dtype apresenta inconsistência pois possue valores de textos misturados com números

E:
"""

colunas_numericas = df.select_dtypes(include=['number']) #seleciona apenas as colunas numericas
matriz_correlacao = colunas_numericas.corr() #calcula a matriz de correlação
print(matriz_correlacao) #printa a matriz de correlação

# Os valores na diagonal principal da matriz representam a variância de cada
# variável. A variância mede a dispersão dos dados em torno da média.
#Fora da diagonal principal: Os valores fora da diagonal principal representam a covariância entre pares de variáveis.
# A covariância mede a relação linear entre duas variáveis.

"""F:"""

pip install seaborn

import seaborn as sns
import matplotlib.pyplot as plt

# Seleciona os atributos preditivos
atributos_preditivos = df.drop(columns=['num'])

# Derrete o DataFrame para o formato longo
df_melted = pd.melt(atributos_preditivos, var_name='Atributo', value_name='Valor')

# Cria o boxplot
plt.figure(figsize=(12, 6))
sns.boxplot(x='Atributo', y='Valor', data=df_melted)
plt.title('Boxplots dos Atributos Preditivos')
plt.xticks(rotation=45, ha='right')
plt.show()

"""CHOL E THALACH POSSUEM OUTLIERS POIS APRESENTAM UMA VARIAÇÃO DE VALORES MAIOR QUE O NORMAL

G:
"""

import matplotlib.pyplot as plt #nova biblioteca para plotar histogramas
print(df.columns) #printa as colunas das bases de dados novamente
import seaborn as sns #importa a biblioteca seaborn
for coluna in df.columns[:-1]:  # iterar sobre todas as colunas, exceto a última ('num')
    plt.figure(figsize=(10, 6))  # define o tamanho da figura

    # plota o histograma para cada classe (0 e 1)
    sns.histplot(df[df['num'] == 0][coluna], label='Classe 0', color='blue', alpha=0.5) #esse comando é usado para plotar os histrogramas das classes
    sns.histplot(df[df['num'] == 1][coluna], label='Classe 1', color='red', alpha=0.5) #num é assumido como coluna de classes

    plt.title(f'Histograma de {coluna} por Classe')  # Título do gráfico
    plt.xlabel(coluna)  # Rótulo do eixo x
    plt.ylabel('Frequência')  # Rótulo do eixo y
    plt.legend()  # Mostra legenda
    plt.show()  # Exibe o gráfico

"""H:"""

import pandas as pd
import seaborn as sns
import matplotlib.pyplot as plt
df = pd.read_csv('https://archive.ics.uci.edu/static/public/45/data.csv')
def remover_outliers_iqr(df, coluna): #remove outliers
    Q1 = df[coluna].quantile(0.25)
    Q3 = df[coluna].quantile(0.75)
    IQR = Q3 - Q1
    df_sem_outliers = df[(df[coluna] >= (Q1 - 1.5 * IQR)) & (df[coluna] <= (Q3 + 1.5 * IQR))]
    return df_sem_outliers

# aplica a função para 'chol'  'thalach'
df_sem_outliers_chol = remover_outliers_iqr(df, 'chol')
df_sem_outliers_thalach = remover_outliers_iqr(df, 'thalach')

# Boxplot para 'chol' sem outliers
sns.boxplot(x='num', y='chol', data=df_sem_outliers_chol)
plt.title('Boxplot de chol sem Outliers')
plt.show()

# Boxplot para 'thalach' sem outliers
sns.boxplot(x='num', y='thalach', data=df_sem_outliers_thalach)
plt.title('Boxplot de thalach sem Outliers')
plt.show()

"""I:"""

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
from sklearn.preprocessing import StandardScaler
from sklearn.decomposition import PCA
from sklearn.impute import SimpleImputer

# seleciona todas as colunas
colunas_numericas = ['age', 'sex', 'cp', 'trestbps', 'chol', 'fbs', 'restecg', 'thalach', 'exang', 'oldpeak', 'slope', 'ca', 'thal']
X = df[colunas_numericas]

# busca os valores perdidos
imputer = SimpleImputer(strategy='mean')
X_imputed = imputer.fit_transform(X)

# organiza os dados
scaler = StandardScaler()
X_padronizado = scaler.fit_transform(X_imputed)

# aplica o pca
pca = PCA(n_components=2)
componentes_principais = pca.fit_transform(X_padronizado)

# cria o plott dos atributos
plt.figure(figsize=(8, 6))
plt.scatter(componentes_principais[:, 0], componentes_principais[:, 1])
plt.xlabel('Componente Principal 1')
plt.ylabel('Componente Principal 2')
plt.title('Gráfico do Espaço de Atributos')
plt.show()

